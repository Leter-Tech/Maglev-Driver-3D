<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" href="favicon-16x16.png" type="image/png" sizes="16x16">
    <link rel="icon" href="favicon-32x32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <link rel="icon" href="android-chrome-192x192.png" type="image/png" sizes="192x192">
    <link rel="icon" href="android-chrome-512x512.png" type="image/png" sizes="512x512">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three/build/three.module.js",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three/examples/jsm/"
            }
        }
        </script>
    <title>Maglev Driver</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bungee&display=swap');

        :root {
            --primary-color: #ff8c00;
            --dark-bg: #1a1a1a;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Bungee', cursive;
            background-color: var(--dark-bg);
            color: #fff;
        }

        canvas {
            display: block;
        }

        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #score, #highScore {
            position: absolute;
            top: 20px;
            font-size: 2em;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
            display: none; 
        }
        #score { left: 20px; }
        #highScore { right: 20px; }

        .overlay {
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.5);
            border: 2px solid var(--primary-color);
            pointer-events: auto;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .overlay h1 {
            font-size: 4em;
            margin: 0;
            color: var(--primary-color);
        }

        .overlay p {
            font-size: 1.2em;
            margin: 20px 0;
            color: #ffffff;
        }
        
        .final-score {
            font-size: 2.5em !important;
            margin-top: 10px !important;
            color: #fff !important;
        }
        
        #difficulty-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 30px;
        }
        
        #difficulty-buttons {
            display: flex;
            gap: 20px;
        }

        .button {
            background: var(--primary-color);
            color: var(--dark-bg);
            padding: 15px 30px;
            font-size: 1.5em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Bungee', cursive;
            transition: all 0.2s ease;
            box-shadow: 0 0 15px var(--primary-color);
            max-width: 80%;
        }

        .button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--primary-color), 0 0 40px var(--primary-color);
        }
        
        #loginBtn {
            font-size: 1.2em;
            padding: 15px 25px;
            margin-top: 20px;
        }
        #loginBtn i {
            margin-right: 10px;
        }

        .button.easy { background: #4caf50; box-shadow: 0 0 15px #4caf50; }
        .button.easy:hover { box-shadow: 0 0 25px #4caf50, 0 0 40px #4caf50; }
        .button.medium { background: #ffc107; box-shadow: 0 0 15px #ffc107; }
        .button.medium:hover { box-shadow: 0 0 25px #ffc107, 0 0 40px #ffc107; }
        .button.hard { background: #f44336; box-shadow: 0 0 15px #f44336; }
        .button.hard:hover { box-shadow: 0 0 25px #f44336, 0 0 40px #f44336; }
        
        .hidden { display: none; }
        
        
        #game-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: auto;
            z-index: 5;
        }
        #game-controls #fsToggleBtn:not([style*="display: none"]) {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #spotify-controls {
            position: absolute;
            bottom: 100px;
            right: 20px;
            display: hidden;
            gap: 10px;
            pointer-events: auto;
            z-index: 5;
        }

        #xyz-controls {
            position: absolute;
            bottom: 100px;
            right: 20px;
            display: hidden;
            gap: 10px;
            pointer-events: auto;
            z-index: 5;
        }
        
        @media (max-width: 800px) {
            #spotify-controls {
                display: none;
            }
        }
        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 1.8em;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
        }
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        #logoutBtn {
            display: none; 
        }

        
        #orientation-lock {
            display: none; 
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--dark-bg);
            color: white;
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #orientation-lock i {
            font-size: 5em;
            margin-bottom: 20px;
            animation: rotate-anim 1.5s ease-in-out infinite;
        }
        @keyframes rotate-anim {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(-90deg); }
            100% { transform: rotate(-90deg); }
        }
        @media (max-width: 800px) and (orientation: portrait) {
            #orientation-lock {
                display: flex;
            }
        }
        
        
        #spotify-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
        }
        
        #spotify-modal-content {
            background: var(--dark-bg);
            border: 2px solid var(--primary-color);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        
        #spotify-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        #spotify-modal h2 {
            color: var(--primary-color);
            margin: 0;
            font-size: 1.8em;
        }
        
        #spotify-modal-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }
        
        #spotify-modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        #spotify-input-section {
            margin-bottom: 20px;
        }
        
        #spotify-input-section p {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1em;
            line-height: 1.4;
        }
        
        #playlist-input {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1em;
            font-family: 'Bungee', cursive;
            box-sizing: border-box;
            margin-bottom: 25px;
        }
        
        #playlist-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        #playlist-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 10px rgba(255, 140, 0, 0.3);
        }
        
        #load-playlist-btn {
            background: var(--primary-color);
            color: #fff;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 1em;
            font-family: 'Bungee', cursive;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 15px var(--primary-color);
        }
        
        #load-playlist-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--primary-color), 0 0 40px var(--primary-color);
        }
        
        #spotify-embed-container {
            display: none;
            margin-top: 20px;
        }
        
        #spotify-embed-container iframe {
            border-radius: 12px;
            width: 100%;
            height: 352px;
            border: none;
        }
        
        #spotify-modal.minimized #spotify-modal-content {
            max-height: 60px;
            overflow: hidden;
            padding: 15px 30px;
        }
        
        #spotify-modal.minimized #spotify-input-section {
            display: none;
        }
        
        #spotify-modal.minimized #spotify-embed-container {
            display: none;
        }
        
        #spotify-modal.minimized #spotify-modal-header h2 {
            font-size: 1.2em;
        }

        
        #control-instructions {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: none;
        }

        .control-overlay {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--primary-color);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .control-text {
            font-size: 1.5em;
            color: #fff;
            margin-bottom: 30px;
            font-family: 'Bungee', cursive;
        }

        
        .keyboard-keys {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .key-group {
            display: flex;
            gap: 15px;
        }

        .key {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 2px solid #444;
            border-radius: 8px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
            font-family: 'Bungee', cursive;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.1s ease;
            position: relative;
        }

        .key.pressed {
            transform: translateY(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
            border-color: var(--primary-color);
        }

        .key-a.pressed, .key-arrow-left.pressed {
            animation: keyPressLeft 0.6s ease-in-out infinite;
        }

        .key-d.pressed, .key-arrow-right.pressed {
            animation: keyPressRight 0.6s ease-in-out infinite;
        }

        @keyframes keyPressLeft {
            0%, 100% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(2px) translateX(-3px); }
            50% { transform: translateY(2px) translateX(-5px); }
            75% { transform: translateY(2px) translateX(-3px); }
        }

        @keyframes keyPressRight {
            0%, 100% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(2px) translateX(3px); }
            50% { transform: translateY(2px) translateX(5px); }
            75% { transform: translateY(2px) translateX(3px); }
        }

        
        .swipe-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .swipe-hand {
            font-size: 3em;
            color: var(--primary-color);
            animation: handSwipe 2s ease-in-out infinite;
        }

        .swipe-arrows {
            display: flex;
            gap: 30px;
        }

        .swipe-arrow {
            font-size: 2em;
            color: #fff;
            animation: arrowPulse 1.5s ease-in-out infinite;
        }

        .swipe-arrow.swipe-left {
            animation-delay: 0s;
        }

        .swipe-arrow.swipe-right {
            animation-delay: 0.75s;
        }

        @keyframes handSwipe {
            0%, 100% { transform: translateX(0) rotate(0deg); }
            25% { transform: translateX(-20px) rotate(-15deg); }
            50% { transform: translateX(-40px) rotate(-30deg); }
            75% { transform: translateX(-20px) rotate(-15deg); }
        }

        @keyframes arrowPulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        
        @media (min-width: 801px) {
            #mobile-controls {
                display: none;
            }
        }

        
        @media (max-width: 800px) {
            #desktop-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    
    <div id="score">Score: 0</div>
    <div id="highScore">High Score: 0</div>

    
    <div id="loginScreen" class="ui-container">
        <div class="overlay">
            <h1>Maglev Driver</h1>
            <div id="fullscreen-prompt" style="display: none; margin-bottom: 20px; text-align: center;">
                <p>Please enter fullscreen mode to play.</p>
                <button id="fullscreenBtn" class="button"><i class="fa-solid fa-expand"></i> Enter Fullscreen</button>
            </div>
            <button id="loginBtn" class="button"><i class="fa-brands fa-google"></i>Login with Google</button>
        </div>
    </div>
    
    <div id="startScreen" class="ui-container hidden">
        <div class="overlay">
            <h1>Maglev Driver</h1>
            <div id="start-fullscreen-prompt" style="display: none; margin-bottom: 20px; text-align: center;">
                <p>Please enter fullscreen mode to play.</p>
                <button id="startFullscreenBtn" class="button"><i class="fa-solid fa-expand"></i> Enter Fullscreen</button>
            </div>
            <div id="difficulty-selection">
                <p>Select Difficulty</p>
                <div id="difficulty-buttons">
                    <button id="easyBtn" class="button easy">Easy</button>
                    <button id="mediumBtn" class="button medium">Medium</button>
                    <button id="hardBtn" class="button hard">Hard</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="gameOverScreen" class="ui-container hidden">
        <div class="overlay">
            <h1>Game Over</h1>
            <p class="final-score">Your Score: <span id="finalScore">0</span></p>
            <button id="restartButton" class="button">Play Again</button>
        </div>
    </div>

    
    <div id="game-controls" class="hidden">
        <button id="logoutBtn" class="control-btn"><i class="fa-solid fa-right-from-bracket"></i></button>
        <button id="soundBtn" class="control-btn"><i id="soundIcon" class="fa-solid fa-volume-xmark"></i></button>
    </div>
    
    <div id="xyz-controls" class="hidden">
        <button id="fsToggleBtn" class="control-btn" style="display: none;"><i id="fsIcon" class="fa-solid fa-expand"></i></button>
    </div>

    <div id="spotify-controls" class="hidden">
        <button id="spotifyBtn" class="control-btn"><i class="fa-brands fa-spotify"></i></button>
    </div>

    
    <div id="orientation-lock">
        <i class="fa-solid fa-mobile-screen"></i>
    </div>
    
    
    <div id="spotify-modal">
        <div id="spotify-modal-content">
            <div id="spotify-modal-header">
                <h2><i class="fa-brands fa-spotify"></i> Spotify Radio</h2>
                <button id="spotify-modal-close"><i class="fa-solid fa-times"></i></button>
            </div>
            <div id="spotify-input-section">
                <p>Enter your Spotify playlist link. You need a Spotify Premium account to use this feature.</p>
                <input type="text" id="playlist-input" placeholder="https://open.spotify.com/playlist/...">
                <button id="load-playlist-btn">Load Playlist</button>
            </div>
            <div id="spotify-embed-container">
                
            </div>
        </div>
    </div>

    
    <div id="control-instructions" class="ui-container hidden" style="display: none;">
        <div class="control-overlay">
            <div id="desktop-controls" class="control-section">
                <p class="control-text">Use A/D or Arrow Keys to control</p>
                <div class="keyboard-keys">
                    <div class="key-group">
                        <div class="key key-a">A</div>
                        <div class="key key-d">D</div>
                    </div>
                    <div class="key-group">
                        <div class="key key-arrow-left">←</div>
                        <div class="key key-arrow-right">→</div>
                    </div>
                </div>
            </div>
            <div id="mobile-controls" class="control-section">
                <p class="control-text">Swipe left or right to control</p>
                <div class="swipe-animation">
                    <div class="swipe-hand">
                        <i class="fa-solid fa-hand"></i>
                    </div>
                    <div class="swipe-arrows">
                        <div class="swipe-arrow swipe-left">←</div>
                        <div class="swipe-arrow swipe-right">→</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    
    <audio id="bgMusic" loop>
        <source src="bgm.mp3" type="audio/mpeg">
    </audio>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getDatabase, ref, set, get } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";
        
        const firebaseConfig = {
            REMOVED
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth();
        const database = getDatabase(app);
        const provider = new GoogleAuthProvider();

        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x00001a);
        scene.fog = new THREE.Fog(0x00001a, 10, 150);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 10);
        camera.lookAt(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        scene.add(directionalLight);
        
        
        let gameSpeed;
        let score = 0;
        let highScore = 0;
        let isGameRunning = false;
        let currentUser = null;
        let lanes = [-6, 0, 6];
        let currentDifficulty;

        const difficultySettings = {
            easy: { initialSpeed: 0.4, maxSpeed: 1.5, spawnTimeMin: 80, spawnTimeRandom: 60 },
            medium: { initialSpeed: 0.6, maxSpeed: 2.2, spawnTimeMin: 50, spawnTimeRandom: 50 },
            hard: { initialSpeed: 0.8, maxSpeed: 3.0, spawnTimeMin: 35, spawnTimeRandom: 25 }
        };
        
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const loginScreen = document.getElementById('loginScreen');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const loginBtn = document.getElementById('loginBtn');
        const gameControls = document.getElementById('game-controls');
        const xyzControls = document.getElementById('xyz-controls');
        const logoutBtn = document.getElementById('logoutBtn');
        const soundBtn = document.getElementById('soundBtn');
        const soundIcon = document.getElementById('soundIcon');
        const bgMusic = document.getElementById('bgMusic');
        bgMusic.volume = 0.06
        let isSoundOn = false;
        let hasUserInteracted = false;
        const fullscreenPrompt = document.getElementById('fullscreen-prompt');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const startFullscreenPrompt = document.getElementById('start-fullscreen-prompt');
        const startFullscreenBtn = document.getElementById('startFullscreenBtn');
        const difficultySelection = document.getElementById('difficulty-selection');
        const fsToggleBtn = document.getElementById('fsToggleBtn');
        const fsIcon = document.getElementById('fsIcon');
        const spotifyBtn = document.getElementById('spotifyBtn');
        const spotifyControls = document.getElementById('spotify-controls');
        const spotifyModal = document.getElementById('spotify-modal');
        const spotifyModalClose = document.getElementById('spotify-modal-close');
        const playlistInput = document.getElementById('playlist-input');
        const loadPlaylistBtn = document.getElementById('load-playlist-btn');
        const spotifyEmbedContainer = document.getElementById('spotify-embed-container');
        const controlInstructions = document.getElementById('control-instructions');
        const isMobile = /Mobi/i.test(navigator.userAgent) && !/iPhone/i.test(navigator.userAgent) && ( /Android/i.test(navigator.userAgent) || /iPad/i.test(navigator.userAgent) );
        const newcheck = /Mobi/i.test(navigator.userAgent);

        if (newcheck) {
            spotifyControls.style.display = 'none';
        }


        if (isMobile) {
            fsToggleBtn.style.display = 'flex';
            spotifyControls.style.display = 'none';
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
            if (!isFullscreen) {
                loginBtn.style.display = 'none';
                fullscreenPrompt.style.display = 'block';
            }
        }
        
        function encodeEmailForPath(email) {
            return email.replace(/\./g, '_DOT_')
                        .replace(/#/g, '_HASH_')
                        .replace(/\$/g, '_DOLLAR_')
                        .replace(/\[/g, '_LBRACKET_')
                        .replace(/\]/g, '_RBRACKET_')
                        .replace(/\//g, '_SLASH_');
        }

        
        async function loadUserHighScore(userEmail) {
            try {
                const encodedEmail = encodeEmailForPath(userEmail);
                const userHighScoreRef = ref(database, `users/${encodedEmail}/highScore`);
                const snapshot = await get(userHighScoreRef);
                if (snapshot.exists()) {
                    highScore = snapshot.val();
                } else {
                    highScore = 0;
                }
                highScoreElement.innerText = `High Score: ${Math.floor(highScore)}`;
            } catch (error) {
                console.error("Error loading user high score:", error);
                highScore = 0;
                highScoreElement.innerText = `High Score: ${Math.floor(highScore)}`;
            }
        }

        
        async function saveUserHighScore(userEmail, newScore) {
            try {
                const encodedEmail = encodeEmailForPath(userEmail);
                const userHighScoreRef = ref(database, `users/${encodedEmail}/highScore`);
                await set(userHighScoreRef, newScore);
            } catch (error) {
                console.error("Error saving user high score:", error);
            }
        }

        highScoreElement.innerText = `High Score: ${Math.floor(highScore)}`;
        renderer.domElement.style.display = 'none';

        
        function handleFirstUserInteraction() {
    if (isMobile) return;
    if (!hasUserInteracted) {
        hasUserInteracted = true;
        isSoundOn = true;
        bgMusic.play().catch(e => console.log("Audio play failed. User interaction needed."));
        soundIcon.classList.replace('fa-volume-xmark', 'fa-volume-high');
        
        
        document.removeEventListener('click', handleFirstUserInteraction);
        document.removeEventListener('touchstart', handleFirstUserInteraction);
    }
}

        
        document.addEventListener('click', handleFirstUserInteraction);
        document.addEventListener('touchstart', handleFirstUserInteraction);

        
        function createCar() {
            const car = new THREE.Group();
            const mainColor = 0xfc2e5a;
            const greyColor = 0x2a2a2a;
            const glassColor = 0x333333;

            
            const chassisShape = new THREE.Shape();
            chassisShape.moveTo(-1.6, -2.8);
            chassisShape.lineTo(1.6, -2.8);
            chassisShape.lineTo(1.6, 2.8);
            chassisShape.lineTo(-1.6, 2.8);
            chassisShape.lineTo(-1.6, -2.8);

            const extrudeSettings = { depth: 1, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelOffset: 0, bevelSegments: 2 };
            const chassisGeo = new THREE.ExtrudeGeometry(chassisShape, extrudeSettings);
            const chassisMat = new THREE.MeshPhongMaterial({ color: mainColor });
            const chassis = new THREE.Mesh(chassisGeo, chassisMat);
            chassis.rotation.x = -Math.PI / 2;
            chassis.position.y = 1.2;
            chassis.castShadow = true;
            car.add(chassis);

            
            const cabinGeo = new THREE.BoxGeometry(2.5, 1, 3);
            const cabinMat = new THREE.MeshPhongMaterial({ color: glassColor, transparent: true, opacity: 0.8 });
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 2.2, -0.4);
            cabin.castShadow = true;
            car.add(cabin);
            
            
            const spoilerGeo = new THREE.BoxGeometry(3, 0.2, 0.8);
            const spoiler = new THREE.Mesh(spoilerGeo, chassisMat);
            spoiler.position.set(0, 1.8, -2.6);
            car.add(spoiler);

            
            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 32);
            const wheelMat = new THREE.MeshPhongMaterial({ color: greyColor });
            const wheelPositions = [
                { x: 1.7, y: 0.5, z: 2.0 }, { x: -1.7, y: 0.5, z: 2.0 },
                { x: 1.7, y: 0.5, z: -2.0 }, { x: -1.7, y: 0.5, z: -2.0 }
            ];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                car.add(wheel);
            });

            return car;
        }

        const car = createCar();
        car.position.z = 2;
        let currentLane = 1;
        car.position.x = lanes[currentLane];
        scene.add(car);
        
        
        const roadLength = 700, roadWidth = 20, road = new THREE.Group();
        const mainRoad = new THREE.Mesh(new THREE.PlaneGeometry(roadWidth, roadLength), new THREE.MeshPhongMaterial({ color: 0x2c2c2c }));
        mainRoad.rotation.x = -Math.PI / 2;
        mainRoad.receiveShadow = true;
        road.add(mainRoad);
          const postGeo = new THREE.BoxGeometry(0.2, 2, 0.2);
        const postMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
        const railGeo = new THREE.BoxGeometry(0.1, 0.1, 8);
        for (let i = 0; i < roadLength / 6; i++) {
            const leftStripe = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 4), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            leftStripe.rotation.x = -Math.PI / 2;
            leftStripe.position.set(-3, 0.01, -roadLength/2 + i*8);
            road.add(leftStripe);
                        const rightStripe = leftStripe.clone();
            rightStripe.position.x = 3;
            road.add(rightStripe);

           
            const zPos = -roadLength/2 + i*8;

           
            const leftPost = new THREE.Mesh(postGeo, postMat);
            leftPost.position.set(-10.2, 1, zPos);
            leftPost.castShadow = true;
            road.add(leftPost);

            const leftRailTop = new THREE.Mesh(railGeo, postMat);
            leftRailTop.position.set(-10.2, 1.8, zPos + 4);
            road.add(leftRailTop);

            const leftRailBottom = new THREE.Mesh(railGeo, postMat);
            leftRailBottom.position.set(-10.2, 1.4, zPos + 4);
            road.add(leftRailBottom);

           
            const rightPost = new THREE.Mesh(postGeo, postMat);
            rightPost.position.set(10.2, 1, zPos);
            rightPost.castShadow = true;
            road.add(rightPost);

            const rightRailTop = new THREE.Mesh(railGeo, postMat);
            rightRailTop.position.set(10.2, 1.8, zPos + 4);
            road.add(rightRailTop);

            const rightRailBottom = new THREE.Mesh(railGeo, postMat);
            rightRailBottom.position.set(10.2, 1.4, zPos + 4);
            road.add(rightRailBottom);
        }
        road.position.y = 0.01;
        scene.add(road);


       
                const floorGeo = new THREE.PlaneGeometry(200, roadLength);
        const floorMat = new THREE.MeshPhongMaterial({ color: 0x004d00 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        const starCount = 5000;
        const starVertices = [];
        const starGeometry = new THREE.BufferGeometry();

        for (let i = 0; i < starCount; i++) {
           
            const x = THREE.MathUtils.randFloatSpread(1500); 
           
            const y = THREE.MathUtils.randFloat(50, 400); 
           
            const z = THREE.MathUtils.randFloat(-200, -1000); 
            starVertices.push(x, y, z);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

        const starMaterial = new THREE.PointsMaterial({
              color: 0xffffff,
            size: 0.5,
            sizeAttenuation: true,
            depthWrite: false,
           blending: THREE.AdditiveBlending,
            fog: false
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

 function createBuildingTexture(colorHex) {
    const canvas = document.createElement('canvas');
    canvas.width = 32;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');

   
    const colorString = '#' + colorHex.toString(16).padStart(6, '0');

   
    ctx.fillStyle = colorString;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

   
    const windowColor = '#FFFF88';
    const windowWidth = 10;
    const windowHeight = 12;
    const hPadding = 6;
    const vPadding = 8;

    ctx.fillStyle = windowColor;

   
    for (let y = vPadding; y < canvas.height - windowHeight; y += windowHeight + vPadding) {
       
        if (Math.random() > 0.3) {
            ctx.fillRect(hPadding / 2, y, windowWidth, windowHeight);
        }
       
        if (Math.random() > 0.3) {
            ctx.fillRect(hPadding / 2 + windowWidth + hPadding, y, windowWidth, windowHeight);
        }
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    return texture;
}


const buildingPool = [];
const buildingColors = [0x333333, 0x555555, 0x4A4A4A, 0x808080, 0x8B0000, 0xB22222, 0x6E2626, 0x654321, 0x2C3E50, 0x556B2F];
const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x303030 });

for (let i = 0; i < 20; i++) {
   
    const building = new THREE.Group();

   
    const height = Math.random() * 10 + 20;
    const width = Math.random() * 5 + 8;
    const depth = Math.random() * 5 + 8;
    const baseColor = buildingColors[Math.floor(Math.random() * buildingColors.length)];

   
    const windowTexture = createBuildingTexture(baseColor);
   
   
    windowTexture.repeat.set(width / 8, height / 16);

    const windowMaterial = new THREE.MeshPhongMaterial({
        map: windowTexture,
    });


    const materials = [
        windowMaterial,
        windowMaterial,
        roofMaterial,  
        roofMaterial,  
        windowMaterial,
        windowMaterial 
    ];

    const mainBlock = new THREE.Mesh(
        new THREE.BoxGeometry(width, height, depth),
        materials
    );
    mainBlock.castShadow = true;
    mainBlock.receiveShadow = true;
    mainBlock.position.y = height / 2;
    building.add(mainBlock);

    let currentTopY = height;

   
    if (Math.random() > 0.4) {
        const topHeight = Math.random() * (height * 0.4) + (height * 0.2);
        const topWidth = width * (Math.random() * 0.3 + 0.5);
        const topDepth = depth * (Math.random() * 0.3 + 0.5);

       
        const topTexture = createBuildingTexture(baseColor);
        topTexture.repeat.set(topWidth / 8, topHeight / 16);
        const topWindowMaterial = new THREE.MeshPhongMaterial({ map: topTexture });

        const topMaterials = [
            topWindowMaterial, roofMaterial, roofMaterial,
            roofMaterial, topWindowMaterial, topWindowMaterial
        ];
        
        const topBlock = new THREE.Mesh(
            new THREE.BoxGeometry(topWidth, topHeight, topDepth),
            topMaterials
        );
        topBlock.castShadow = true;
        topBlock.receiveShadow = true;
       
        topBlock.position.y = currentTopY + (topHeight / 2);
        building.add(topBlock);
        currentTopY += topHeight;
    }
    
   
    if (Math.random() > 0.7) {
        const antennaHeight = Math.random() * 10 + 5;
        const antennaGeo = new THREE.CylinderGeometry(0.3, 0.3, antennaHeight, 8);
        const antennaMat = new THREE.MeshPhongMaterial({ color: 0xCCCCCC });
        const antenna = new THREE.Mesh(antennaGeo, antennaMat);
        
        antenna.castShadow = true;
        antenna.position.y = currentTopY + (antennaHeight / 2);
        building.add(antenna);
    }

   
   
   
   

    building.visible = false;
    buildingPool.push(building);
    scene.add(building);
}

function createTree() {
    const tree = new THREE.Group();
    
   
    const trunkGeo = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
    const trunkMat = new THREE.MeshPhongMaterial({ color: 0x4d2926 }); 
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 1;
    trunk.castShadow = true;
    tree.add(trunk);

   
    const leavesGeo = new THREE.ConeGeometry(1.5, 4, 8);
    const leavesMat = new THREE.MeshPhongMaterial({ color: 0x006400 });
    const leaves = new THREE.Mesh(leavesGeo, leavesMat);
    leaves.position.y = 3;
    leaves.castShadow = true;
    tree.add(leaves);
    
    return tree;
}

const treePool = [];
for (let i = 0; i < 100; i++) {
    const tree = createTree();
    tree.visible = false;
    treePool.push(tree);
    scene.add(tree);
}

        function spawnBuilding(z) {
            const building = buildingPool.find(b => !b.visible);
            if (building) {
                building.visible = true;
                building.position.x = Math.random() > 0.5 ? 25 : -25;
                building.position.z = z;
            }
        }
       

function spawnTree(z) {
    const tree = treePool.find(t => !t.visible);
    if (tree) {
        tree.visible = true;
        
       
        const side = Math.random() > 0.5 ? 1 : -1;
       
        tree.position.x = side * (THREE.MathUtils.randFloat(30, 95)); 
        
       
        tree.position.z = z + (THREE.MathUtils.randFloat(-30, 0)); 
    }
}
        
        const obstaclePool = [];
        for (let i = 0; i < 15; i++) {
            const obstacle = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), new THREE.MeshPhongMaterial({ color: 0xffa500 }));
            obstacle.castShadow = true;
            obstacle.visible = false;
            obstacle.position.y = 1.5;
            obstaclePool.push(obstacle);
            scene.add(obstacle);
        }
        function spawnObstacle() {
            const obstacle = obstaclePool.find(o => !o.visible);
            if (obstacle) {
                obstacle.visible = true;
                obstacle.position.x = lanes[Math.floor(Math.random() * 3)];
                obstacle.position.z = -150;
            }
        }

        

function resetGame() {
    car.position.set(lanes[1], 0, 2);
    currentLane = 1;
    gameSpeed = currentDifficulty.initialSpeed;
    score = 0;
    obstaclePool.forEach(o => o.visible = false);
    buildingPool.forEach(b => b.visible = false);
    treePool.forEach(t => t.visible = false);

    for (let i = 0; i < 10; i++) spawnBuilding(-i * 30);

   
    for (let i = 0; i < 80; i++) { 
        spawnTree(-i * 3);
    }
}

        function showControlInstructions() {
            controlInstructions.style.display = 'flex';
            controlInstructions.classList.remove('hidden');
            
           
            const desktopControls = document.getElementById('desktop-controls');
            const mobileControls = document.getElementById('mobile-controls');
            
            if (isMobile || newcheck) {
                desktopControls.style.display = 'none';
                mobileControls.style.display = 'block';
            } else {
                desktopControls.style.display = 'block';
                mobileControls.style.display = 'none';
            }
            
            const keyA = document.querySelector('.key-a');
            const keyD = document.querySelector('.key-d');
            const keyArrowLeft = document.querySelector('.key-arrow-left');
            const keyArrowRight = document.querySelector('.key-arrow-right');
            
            setTimeout(() => {
                keyA.classList.add('pressed');
                keyArrowLeft.classList.add('pressed');
            }, 500);
            
            setTimeout(() => {
                keyA.classList.remove('pressed');
                keyArrowLeft.classList.remove('pressed');
                keyD.classList.add('pressed');
                keyArrowRight.classList.add('pressed');
            }, 1000);
            
            setTimeout(() => {
                keyD.classList.remove('pressed');
                keyArrowRight.classList.remove('pressed');
            }, 1500);
            
            setTimeout(() => {
                controlInstructions.classList.add('hidden');
                controlInstructions.style.display = 'none';
            }, 2000);
        }

        function startGame(difficulty) {
            currentDifficulty = difficultySettings[difficulty];
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            renderer.domElement.style.display = 'block';
            
           
            showControlInstructions();
            
           
            setTimeout(() => {
                isGameRunning = true;
                gameControls.classList.remove('hidden');
                xyzControls.classList.remove('hidden');
                spotifyControls.classList.remove('hidden');
                resetGame();
            }, 2000);
        }

        function gameOver() {
            isGameRunning = false;
            if (score > highScore && currentUser) {
                highScore = score;
                saveUserHighScore(currentUser.email, highScore);
                highScoreElement.innerText = `High Score: ${Math.floor(highScore)}`;
            }
            finalScoreElement.innerText = Math.floor(score);
            gameOverScreen.classList.remove('hidden');
            gameControls.classList.add('hidden');
        }
        
        
        onAuthStateChanged(auth, user => {
            if (user) {
                currentUser = user;
                
                loadUserHighScore(user.email);
                loginScreen.classList.add('hidden');
                startScreen.classList.remove('hidden');
                 if (isMobile) {
                    const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
                    if (isFullscreen) {
                        startFullscreenPrompt.style.display = 'none';
                        difficultySelection.style.display = 'flex';
                    } else {
                        startFullscreenPrompt.style.display = 'block';
                        difficultySelection.style.display = 'none';
                    }
                } else {
                    difficultySelection.style.display = 'flex';
                }
                scoreElement.style.display = 'block';
                highScoreElement.style.display = 'block';
                logoutBtn.style.display = 'flex';
                spotifyControls.classList.remove('hidden');
            } else {
                currentUser = null;
                loginScreen.classList.remove('hidden');
                startScreen.classList.add('hidden');
                gameOverScreen.classList.add('hidden');
                scoreElement.style.display = 'none';
                highScoreElement.style.display = 'none';
                renderer.domElement.style.display = 'none';
                logoutBtn.style.display = 'none';
                spotifyControls.classList.add('hidden');
                if(isGameRunning) {
                    isGameRunning = false;
                }
                gameControls.classList.add('hidden');
                xyzControls.classList.add('hidden');

               
                if (isMobile) {
                    startFullscreenPrompt.style.display = 'none'; 
                    const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
                    if (isFullscreen) {
                       
                        fullscreenPrompt.style.display = 'none';
                        loginBtn.style.display = 'block';
                    } else {
                       
                        fullscreenPrompt.style.display = 'block';
                        loginBtn.style.display = 'none';
                    }
                } else {
                   
                    loginBtn.style.display = 'block';
                }
            }
        });
        
        loginBtn.addEventListener('click', () => {
            signInWithPopup(auth, provider).catch(error => console.error("Login failed:", error));
        });
        
        logoutBtn.addEventListener('click', () => {
            signOut(auth).catch(error => console.error("Logout failed:", error));
        });

        
        document.getElementById('easyBtn').addEventListener('click', () => startGame('easy'));
        document.getElementById('mediumBtn').addEventListener('click', () => startGame('medium'));
        document.getElementById('hardBtn').addEventListener('click', () => startGame('hard'));
        document.getElementById('restartButton').addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            if (isMobile) {
                const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
                if (isFullscreen) {
                    startFullscreenPrompt.style.display = 'none';
                    difficultySelection.style.display = 'flex';
                } else {
                    startFullscreenPrompt.style.display = 'block';
                    difficultySelection.style.display = 'none';
                }
            }
        });
        
        
        let touchStartX = 0;
        let touchEndX = 0;

        function handleMove(direction) {
            if (!isGameRunning) return;
            if (direction === 'left' && currentLane > 0) currentLane--;
            if (direction === 'right' && currentLane < 2) currentLane++;
        }
        
        window.addEventListener('keydown', e => {
            if (e.key === 'a' || e.key === 'ArrowLeft') handleMove('left');
            if (e.key === 'd' || e.key === 'ArrowRight') handleMove('right');
        });

        window.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        }, { passive: false });

        window.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            if (Math.abs(touchStartX - touchEndX) < 50) return;
            if (touchEndX < touchStartX) handleMove('left');
            if (touchEndX > touchStartX) handleMove('right');
        });
        
        
        soundBtn.addEventListener('click', () => {
            isSoundOn = !isSoundOn;
            if (isSoundOn) {
                bgMusic.play().catch(e => console.log("Audio play failed. User interaction needed."));
                soundIcon.classList.replace('fa-volume-xmark', 'fa-volume-high');
            } else {
                bgMusic.pause();
                soundIcon.classList.replace('fa-volume-high', 'fa-volume-xmark');
            }
        });

        function enterFullscreen() {
    if (!hasUserInteracted && isMobile) {
        hasUserInteracted = true;
        isSoundOn = true;
        bgMusic.play().catch(e => console.log("Audio play failed on fullscreen attempt."));
        soundIcon.classList.replace('fa-volume-xmark', 'fa-volume-high');
        document.removeEventListener('click', handleFirstUserInteraction);
        document.removeEventListener('touchstart', handleFirstUserInteraction);
    }
    const el = document.documentElement;
    if (el.requestFullscreen) {
        el.requestFullscreen().catch(err => {
            console.error(`Could not enter fullscreen.`);
        });
    } else if (el.webkitRequestFullscreen) {
        el.webkitRequestFullscreen();
    } else if (el.msRequestFullscreen) {
        el.msRequestFullscreen();
    }
}

       
        function extractPlaylistId(url) {
            const regex = /playlist\/([a-zA-Z0-9]+)/;
            const match = url.match(regex);
            return match ? match[1] : null;
        }
        
        function createSpotifyEmbed(playlistId) {
            const iframe = document.createElement('iframe');
            iframe.setAttribute('data-testid', 'embed-iframe');
            iframe.style.borderRadius = '12px';
            iframe.src = `https://open.spotify.com/embed/playlist/${playlistId}?utm_source=generator`;
            iframe.width = '100%';
            iframe.height = '352';
            iframe.frameBorder = '0';
            iframe.allowfullscreen = '';
            iframe.allow = 'autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture';
            iframe.loading = 'lazy';
            return iframe;
        }
        
        function openSpotifyModal() {
            spotifyModal.style.display = 'flex';
        }
        
        function closeSpotifyModal() {
            spotifyModal.style.display = 'none';
            spotifyModal.classList.remove('minimized');
        }
        
        function toggleSpotifyModal() {
            if (spotifyModal.style.display === 'none' || spotifyModal.style.display === '') {
                openSpotifyModal();
            } else if (spotifyModal.classList.contains('minimized')) {
                spotifyModal.classList.remove('minimized');
            } else {
                spotifyModal.classList.add('minimized');
            }
        }
        
        function loadPlaylist() {
            const url = playlistInput.value.trim();
            if (!url) {
                alert('Please enter a Spotify playlist URL');
                return;
            }
            
            const playlistId = extractPlaylistId(url);
            if (!playlistId) {
                alert('Invalid Spotify playlist URL. Please make sure it\'s a valid playlist link.');
                return;
            }
            
           
            spotifyEmbedContainer.innerHTML = '';
            
           
            const embed = createSpotifyEmbed(playlistId);
            spotifyEmbedContainer.appendChild(embed);
            spotifyEmbedContainer.style.display = 'block';
            
           
            if (isSoundOn) {
                bgMusic.pause();
                soundIcon.classList.replace('fa-volume-high', 'fa-volume-xmark');
                isSoundOn = false;
            }
        }
        
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
        
        fullscreenBtn.addEventListener('click', enterFullscreen);
        startFullscreenBtn.addEventListener('click', enterFullscreen);
        
        fsToggleBtn.addEventListener('click', () => {
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
            if (isFullscreen) {
                exitFullscreen();
            } else {
                enterFullscreen();
            }
        });
        
       
        spotifyBtn.addEventListener('click', toggleSpotifyModal);
        spotifyModalClose.addEventListener('click', closeSpotifyModal);
        loadPlaylistBtn.addEventListener('click', loadPlaylist);
        
       
        spotifyModal.addEventListener('click', (e) => {
            if (e.target === spotifyModal) {
                closeSpotifyModal();
            }
        });
        
       
        playlistInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loadPlaylist();
            }
        });
        
        function handleFullscreenChange() {
            if (!isMobile) return;
            const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
            if (isFullscreen) {
                if (!loginScreen.classList.contains('hidden')) {
                    fullscreenPrompt.style.display = 'none';
                    loginBtn.style.display = 'block';
                }
                if (!startScreen.classList.contains('hidden')) {
                    startFullscreenPrompt.style.display = 'none';
                    difficultySelection.style.display = 'flex';
                }
                fsIcon.classList.replace('fa-expand', 'fa-compress');
            } else {
                if (isGameRunning) {
                    gameOver();
                }
                fsIcon.classList.replace('fa-compress', 'fa-expand');
                if (!loginScreen.classList.contains('hidden')) {
                    fullscreenPrompt.style.display = 'block';
                    loginBtn.style.display = 'none';
                }
                if (!startScreen.classList.contains('hidden')) {
                    startFullscreenPrompt.style.display = 'block';
                    difficultySelection.style.display = 'none';
                }
            }
        }
        
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('msfullscreenchange', handleFullscreenChange);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        

let obstacleSpawnTimer = 0, buildingSpawnTimer = 0;
function animate() {
    requestAnimationFrame(animate);
    if (isGameRunning) {
        road.position.z += gameSpeed;
        obstaclePool.forEach(o => { if (o.visible) o.position.z += gameSpeed; });
        buildingPool.forEach(b => { if (b.visible) b.position.z += gameSpeed; });
        treePool.forEach(t => { if (t.visible) t.position.z += gameSpeed; });

        if (road.position.z > 150) road.position.z = 0;

        car.position.x = THREE.MathUtils.lerp(car.position.x, lanes[currentLane], 0.2);

        obstaclePool.forEach(o => { if (o.visible && o.position.z > 20) o.visible = false; });
        buildingPool.forEach(b => { if (b.visible && b.position.z > 20) b.visible = false; });
        treePool.forEach(t => { if (t.visible && t.position.z > 20) t.visible = false; });
        
        obstacleSpawnTimer -= gameSpeed;
        if (obstacleSpawnTimer <= 0) {
            spawnObstacle();
            obstacleSpawnTimer = Math.random() * currentDifficulty.spawnTimeRandom + currentDifficulty.spawnTimeMin;
        }
        
        buildingSpawnTimer -= gameSpeed;
        if(buildingSpawnTimer <= 0) {
            spawnBuilding(-150);
            buildingSpawnTimer = Math.random() * 20 + 10;
            
           
            for (let i = 0; i < 10; i++) { 
                spawnTree(-150);
            }
        }
        
        if (gameSpeed < currentDifficulty.maxSpeed) gameSpeed += 0.001;
        score += gameSpeed * 0.5;
        scoreElement.innerText = `Score: ${Math.floor(score)}`;
        const carBox = new THREE.Box3().setFromObject(car);
        obstaclePool.forEach(o => {
            if (o.visible) {
                const obstacleBox = new THREE.Box3().setFromObject(o);
                if (carBox.intersectsBox(obstacleBox)) gameOver();
            }
        });
    }
    renderer.render(scene, camera);
}
animate();
    </script>
</body>
</html>